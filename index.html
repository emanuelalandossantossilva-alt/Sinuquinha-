<!DOCTYPE html>  
<html lang="pt-br">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">  
    <title>Sinuquinha - Mira Semáforo</title>  
    <style>  
        * { touch-action: none; user-select: none; -webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0; padding: 0; }  
        html, body { background: #050505; overflow: hidden; width: 100vw; height: 100vh; position: fixed; top: 0; left: 0; font-family: sans-serif; }  
        canvas { display: block; width: 100%; height: 100%; }
        
        #fullscreen-btn { 
            position: absolute; top: 20px; right: 20px; z-index: 100; 
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); 
            color: white; padding: 10px; border-radius: 5px; font-size: 12px; cursor: pointer; pointer-events: auto; 
        }

        #power-container { position: absolute; top: 0; left: 0; width: 100%; height: 8px; background: rgba(0,0,0,0.5); z-index: 20; }
        #power-meter { width: 0%; height: 100%; background: linear-gradient(90deg, #00ff88, #ffff00, #ff4400); box-shadow: 0 0 15px rgba(0,255,136,0.7); }
        #ui-overlay { position: absolute; bottom: 25px; left: 50%; transform: translateX(-50%); color: white; text-align: center; pointer-events: none; z-index: 30; width: 100%; }
        .status-msg { font-size: 14px; font-weight: bold; background: rgba(20,10,5,0.85); padding: 10px 20px; border-radius: 8px; border: 1px solid #5d3a1a; color: #f0dca8; display: inline-block; min-width: 320px; }
    </style>
</head>  
<body>  
    <div id="fullscreen-btn">TELA CHEIA</div>
    <div id="power-container"><div id="power-meter"></div></div>
    <div id="ui-overlay">
        <div id="turn-msg" style="font-size:14px; margin-bottom:5px; text-transform:uppercase; letter-spacing:2px; font-weight:bold; color:#00ff88;">JOGADOR 1</div>
        <div id="status-text" class="status-msg">Verde = Certo | Vermelho = Falta</div>
    </div>

<script type="module">  
    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';  

    const btnFs = document.getElementById('fullscreen-btn');
    btnFs.addEventListener('click', () => {
        if (!document.fullscreenElement) { 
            document.documentElement.requestFullscreen().catch(e => console.log(e)); 
            btnFs.innerText = "SAIR TELA CHEIA"; 
        } else { 
            document.exitFullscreen(); 
            btnFs.innerText = "TELA CHEIA"; 
        }
    });

    let gameState = { 
        modoDefinido: false, turno: 1, p1Tipo: null, p2Tipo: null, 
        fezPontoRodada: false, aguardandoReset: false,
        primeiraBolaAtingida: null, bateuNaTabela: false, brancaCaiu: false,
        matouAdversariaSemQuerer: false
    };

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0a0502, 0.012);
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.userData.currentLook = new THREE.Vector3(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const luzFoco = new THREE.SpotLight(0xfff5e0, 4.5); 
    luzFoco.position.set(0, 50, 0); luzFoco.castShadow = true;
    scene.add(luzFoco, new THREE.AmbientLight(0x402010, 0.5));

    const ALTURA_MESA = 7.0, RAIO = 0.62, FRICCAO = 0.9965, REBOTE_TABELA = 0.7; 
    const Y_BOLAS = ALTURA_MESA + 1.0 + RAIO, LIMITE_X = 9.25, LIMITE_Z = 17.45;
    const feltroMat = new THREE.MeshStandardMaterial({ color: 0x021a0e, roughness: 0.9 });
    const madeiraMat = new THREE.MeshStandardMaterial({ color: 0x2d1804, roughness: 0.5 }); 
    const aroInternoMat = new THREE.MeshStandardMaterial({ color: 0x2d1804, roughness: 0.5 });

    const mesaCorpo = new THREE.Mesh(new THREE.BoxGeometry(20, 1.5, 36), feltroMat);
    mesaCorpo.position.y = ALTURA_MESA + 0.25; scene.add(mesaCorpo);

    function criarTabela(largura, x, z, rot) {
        const g = new THREE.Group();
        const s = new THREE.Shape();
        s.moveTo(-largura/2+0.5, 0); s.lineTo(largura/2-0.5, 0); s.absarc(largura/2-0.5, 0.6, 0.6, -Math.PI/2, 0, false);
        s.lineTo(largura/2, 1.2); s.lineTo(-largura/2, 1.2); s.absarc(-largura/2+0.5, 0.6, 0.6, Math.PI, Math.PI*1.5, false);
        const mf = new THREE.Mesh(new THREE.ExtrudeGeometry(s, { depth: 0.8 }), feltroMat);
        const mm = new THREE.Mesh(new THREE.BoxGeometry(largura, 0.9, 0.9), madeiraMat);
        mm.position.set(0, 1.6, 0.4); g.add(mf, mm); g.rotation.x = -Math.PI/2; g.rotation.z = rot; 
        g.position.set(x, ALTURA_MESA + 0.75, z); scene.add(g);
    }
    criarTabela(16.3, -10, -9.2, Math.PI/2); criarTabela(16.3, 10, -9.2, -Math.PI/2);
    criarTabela(18.2, 0, -18.2, 0); criarTabela(18.2, 0, 18.2, Math.PI);
    criarTabela(16.3, -10, 9.2, Math.PI/2); criarTabela(16.3, 10, 9.2, -Math.PI/2);

    const cacapas = [
        {x:-10.0, z: 18.2, rot: Math.PI/4, isMiddle: false}, {x:10.0,  z: 18.2, rot: -Math.PI/4, isMiddle: false}, 
        {x:-10.5, z:0, rot: Math.PI/2, isMiddle: true}, {x:10.5,  z:0, rot: -Math.PI/2, isMiddle: true},
        {x:-10.0, z:-18.2, rot: 3*Math.PI/4, isMiddle: false}, {x:10.0,  z:-18.2, rot: -3*Math.PI/4, isMiddle: false} 
    ];

    cacapas.forEach(p => {
        const rA = p.isMiddle ? 1.05 : 1.45;
        const aro = new THREE.Mesh(new THREE.TorusGeometry(rA, 0.1, 12, 24), aroInternoMat);
        aro.rotation.x = Math.PI/2; aro.position.set(p.x, ALTURA_MESA + 0.95, p.z); scene.add(aro);
        const arcoM = p.isMiddle ? Math.PI : Math.PI * 1.20;
        const aroM = new THREE.Mesh(new THREE.TorusGeometry(rA + 0.3, 0.45, 12, 32, arcoM), madeiraMat);
        aroM.position.set(p.isMiddle ? (p.x < 0 ? p.x - 0.1 : p.x + 0.1) : p.x, ALTURA_MESA + 1.15, p.z); 
        aroM.rotation.x = Math.PI/2; aroM.rotation.z = p.rot - (p.isMiddle ? 0 : (arcoM - Math.PI) / 2); scene.add(aroM);
        const tampa = new THREE.Mesh(new THREE.CircleGeometry(rA - 0.05, 24), new THREE.MeshBasicMaterial({ color: 0x000000 }));
        tampa.rotation.x = -Math.PI/2; tampa.position.set(p.x, ALTURA_MESA + 1.01, p.z); scene.add(tampa);
    });

    const bolas = [];
    function criarBola(cor, num, pos) {
        const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d'); ctx.fillStyle = cor; ctx.fillRect(0,0,128,128);
        ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(64,64,35,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = 'black'; ctx.font = 'bold 40px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(num,64,64);
        const group = new THREE.Group();
        const mat = new THREE.MeshStandardMaterial({ map: new THREE.CanvasTexture(canvas), roughness: 0.1 });
        const b = new THREE.Mesh(new THREE.SphereGeometry(RAIO, 32, 32), mat);
        const sMat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(gerarTexturaBrilho()), transparent: true, opacity: 0, blending: THREE.AdditiveBlending });
        const glow = new THREE.Sprite(sMat); glow.scale.set(RAIO*3, RAIO*3, 1);
        group.add(b, glow); group.position.copy(pos);
        group.userData = { vx:0, vz:0, ativa:true, caindo: false, isBranca: num===".", numero: num === "." ? 0 : parseInt(num), tipo: (parseInt(num)||0)%2===0?'par':'impar', mesh: b, glow: glow };
        scene.add(group); bolas.push(group); return group;
    }

    function gerarTexturaBrilho() {
        const c = document.createElement('canvas'); c.width = 64; c.height = 64;
        const ctx = c.getContext('2d');
        const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        grad.addColorStop(0, 'rgba(255,255,255,1)'); grad.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = grad; ctx.fillRect(0,0,64,64); return c;
    }

    function removerBolaAdversario(qtd) {
        const tipoOponente = (gameState.turno === 1) ? gameState.p2Tipo : gameState.p1Tipo;
        let oponenteBolas = bolas.filter(b => b.userData.ativa && !b.userData.isBranca && b.userData.numero !== 1 && (!gameState.modoDefinido || b.userData.tipo === tipoOponente));
        oponenteBolas.sort((a, b) => a.userData.numero - b.userData.numero);
        for(let i=0; i < qtd && i < oponenteBolas.length; i++) { oponenteBolas[i].userData.ativa = false; scene.remove(oponenteBolas[i]); }
    }

    const branca = criarBola('#ffffff', '.', new THREE.Vector3(0, Y_BOLAS, 8));
    const bola1 = criarBola('#ffcc00', '1', new THREE.Vector3(0, Y_BOLAS, 17.2));

    const coresC = { '2': '#0000ff', '3': '#ff0000', '4': '#4b0082', '5': '#ff69b4', '6': '#008000', '7': '#5d3a1a', '8': '#111111', '9': '#ffd700', '10': '#0000ff', '11': '#ff0000', '12': '#4b0082', '13': '#ff69b4', '14': '#008000', '15': '#5d3a1a' };
    let bIdx = 2;
    for (let r = 1; r < 5; r++) { for (let i = 0; i <= r; i++) { if (bIdx <= 15) { const x = (i - r * 0.5) * (RAIO * 2.05); const z = -8 - (r * RAIO * 1.85); criarBola(coresC[bIdx.toString()], bIdx.toString(), new THREE.Vector3(x, Y_BOLAS, z)); bIdx++; } } }

    const taco = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.05, 25, 16), madeiraMat); scene.add(taco);
    const ghostBall = new THREE.Mesh(new THREE.SphereGeometry(RAIO, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15, wireframe: true })); scene.add(ghostBall);
    const ghostStopBall = new THREE.Mesh(new THREE.SphereGeometry(RAIO, 16, 16), new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.4 })); scene.add(ghostStopBall);

    let angH = 0, rawForca = 0, altCam = 18, touchPos = { x: 0, y: 0 }, isCharging = false, mesaMovendo = false;
    let alvoCamera = branca;

    window.ontouchstart = (e) => { if(mesaMovendo || gameState.aguardandoReset) return; touchPos={x:e.touches[0].clientX, y:e.touches[0].clientY}; isCharging=(touchPos.x > window.innerWidth*0.7); };
    window.ontouchmove = (e) => {
        const t = e.touches[0];
        if(isCharging) { rawForca = Math.max(0, Math.min(1.0, (t.clientY - touchPos.y)/250)); document.getElementById('power-meter').style.width = (rawForca*100)+'%'; }
        else if(!mesaMovendo) { angH -= (t.clientX - touchPos.x)*0.005; altCam = Math.max(9, Math.min(48, altCam + (t.clientY - touchPos.y)*0.2)); touchPos={x:t.clientX, y:t.clientY}; }
    };
    window.ontouchend = () => { if(!mesaMovendo && isCharging && rawForca > 0.01) { const f = Math.pow(rawForca, 1.6)*4.2; branca.userData.vx = Math.sin(angH)*-f; branca.userData.vz = Math.cos(angH)*-f; gameState.fezPontoRodada = false; gameState.primeiraBolaAtingida = null; gameState.bateuNaTabela = false; gameState.brancaCaiu = false; gameState.matouAdversariaSemQuerer = false; } isCharging=false; rawForca=0; document.getElementById('power-meter').style.width='0%'; };

    function loop() {
        requestAnimationFrame(loop);
        for(let s=0; s<6; s++) {
            bolas.forEach(b => {
                if(!b.userData.ativa) return;
                const meuTipo = (gameState.turno === 1) ? gameState.p1Tipo : gameState.p2Tipo;
                if (!b.userData.isBranca && gameState.modoDefinido && b.userData.tipo === meuTipo) { b.userData.glow.material.opacity = 0.4 + Math.sin(Date.now()*0.005)*0.2; b.userData.glow.material.color.setHex(gameState.turno === 1 ? 0x00ff88 : 0x00d9ff); } else { b.userData.glow.material.opacity = 0; }
                if(b.userData.caindo) {
                    alvoCamera = b; b.position.y -= 0.15; 
                    if(b.position.y < ALTURA_MESA-2) { 
                        let eraBranca = b.userData.isBranca; if(eraBranca) gameState.brancaCaiu = true;
                        if(b.userData.numero === 1) { alert("FIM DE JOGO!"); location.reload(); }
                        b.userData.ativa=false; scene.remove(b); gameState.aguardandoReset = true;
                        setTimeout(()=>{
                            if(eraBranca) { b.position.set(0,Y_BOLAS,10); b.userData.vx=b.userData.vz=0; b.userData.ativa=true; b.userData.caindo=false; scene.add(b); removerBolaAdversario(1); }
                            else if(!gameState.modoDefinido) { gameState.modoDefinido = true; gameState.p1Tipo = (gameState.turno === 1) ? b.userData.tipo : (b.userData.tipo === 'par' ? 'impar' : 'par'); gameState.p2Tipo = (gameState.p1Tipo === 'par') ? 'impar' : 'par'; gameState.fezPontoRodada = true; } 
                            else if(b.userData.tipo === meuTipo) { gameState.fezPontoRodada = true; }
                            else { gameState.matouAdversariaSemQuerer = true; }
                            alvoCamera = branca; gameState.aguardandoReset = false;
                        }, 1800);
                    }
                    return;
                }
                const spd = Math.hypot(b.userData.vx, b.userData.vz);
                if(spd > 0.001) {
                    b.position.x += b.userData.vx/6; b.position.z += b.userData.vz/6;
                    b.userData.mesh.rotateOnWorldAxis(new THREE.Vector3(b.userData.vz, 0, -b.userData.vx).normalize(), (spd/6)/RAIO);
                    b.userData.vx *= FRICCAO; b.userData.vz *= FRICCAO;
                    cacapas.forEach(c => { if(Math.hypot(b.position.x-c.x, b.position.z-c.z) < 1.35) b.userData.caindo=true; });
                    if(Math.abs(b.position.x) > LIMITE_X) { b.userData.vx *= -REBOTE_TABELA; b.position.x = Math.sign(b.position.x)*LIMITE_X; if(b===branca && !gameState.primeiraBolaAtingida) gameState.bateuNaTabela = true; }
                    if(Math.abs(b.position.z) > LIMITE_Z) { b.userData.vz *= -REBOTE_TABELA; b.position.z = Math.sign(b.position.z)*LIMITE_Z; if(b===branca && !gameState.primeiraBolaAtingida) gameState.bateuNaTabela = true; }
                }
            });
            for(let i=0; i<bolas.length; i++) {
                for(let j=i+1; j<bolas.length; j++) {
                    const b1=bolas[i], b2=bolas[j]; if(!b1.userData.ativa || !b2.userData.ativa || b1.userData.caindo || b2.userData.caindo) continue;
                    const dx=b2.position.x-b1.position.x, dz=b2.position.z-b1.position.z, d=Math.hypot(dx,dz);
                    if(d < RAIO*2) {
                        const nx=dx/d, nz=dz/d, vRel = (b1.userData.vx-b2.userData.vx)*nx + (b1.userData.vz-b2.userData.vz)*nz;
                        if(vRel > 0) { 
                            if(b1 === branca && !gameState.primeiraBolaAtingida) gameState.primeiraBolaAtingida = b2;
                            if(b2 === branca && !gameState.primeiraBolaAtingida) gameState.primeiraBolaAtingida = b1;
                            const imp = 1.02*vRel; b1.userData.vx -= imp*nx; b1.userData.vz -= imp*nz; b2.userData.vx += imp*nx; b2.userData.vz += imp*nz; 
                        }
                    }
                }
            }
        }

        const movendoAntigo = mesaMovendo;
        mesaMovendo = bolas.some(b => b.userData.ativa && (Math.hypot(b.userData.vx, b.userData.vz) > 0.005 || b.userData.caindo));
        
        if (movendoAntigo && !mesaMovendo && !gameState.aguardandoReset) {
            const meuTipo = (gameState.turno === 1) ? gameState.p1Tipo : gameState.p2Tipo;
            let status = "Sua vez!"; let trocaTurno = !gameState.fezPontoRodada || gameState.matouAdversariaSemQuerer;
            if(gameState.brancaCaiu) { status = "SUICÍDIO! (-1 bola)"; trocaTurno = true; } 
            else if(gameState.matouAdversariaSemQuerer) { status = "MATOU A DO OPONENTE! PERDEU A VEZ"; }
            else if(gameState.modoDefinido) {
                if(!gameState.primeiraBolaAtingida) { removerBolaAdversario(1); status = "SEGA! (-1 bola)"; trocaTurno = true; }
                else if(gameState.primeiraBolaAtingida.userData.numero === 1 && !gameState.bateuNaTabela) { removerBolaAdversario(1); status = "DIRETO NA 1! (-1 bola)"; trocaTurno = true; }
                else if(gameState.primeiraBolaAtingida.userData.tipo !== meuTipo && gameState.primeiraBolaAtingida.userData.numero !== 1) { 
                    const pen = gameState.bateuNaTabela ? 1 : 2; removerBolaAdversario(pen); status = pen === 2 ? "DIRETO NO OPONENTE! (-2)" : "FALTA COM TABELA! (-1)"; trocaTurno = true; 
                }
            }
            if(trocaTurno) gameState.turno = (gameState.turno === 1) ? 2 : 1;
            document.getElementById('status-text').innerText = status;
            document.getElementById('turn-msg').innerText = "JOGADOR " + gameState.turno;
            document.getElementById('turn-msg').style.color = gameState.turno === 1 ? "#00ff88" : "#00d9ff";
        }

        const dX = -Math.sin(angH), dZ = -Math.cos(angH);
        let distColisao = 1000, alvoMira = null;
        bolas.forEach(b => { 
            if(!b.userData.ativa || b===branca || b.userData.caindo) return; 
            const bx=b.position.x-branca.position.x, bz=b.position.z-branca.position.z, proj = bx*dX + bz*dZ; 
            if(proj>0) { 
                const dR = Math.hypot(bx-dX*proj, bz-dZ*proj); 
                if(dR < RAIO*2) { 
                    const dC = proj - Math.sqrt(Math.pow(RAIO*2,2)-Math.pow(dR,2)); 
                    if(dC < distColisao) { distColisao = dC; alvoMira = b; }
                } 
            } 
        });

        if(distColisao === 1000) {
            let tX = dX > 0 ? (LIMITE_X - branca.position.x)/dX : (-LIMITE_X - branca.position.x)/dX;
            let tZ = dZ > 0 ? (LIMITE_Z - branca.position.z)/dZ : (-LIMITE_Z - branca.position.z)/dZ;
            distColisao = Math.min(tX, tZ); alvoMira = null;
        }

        ghostBall.visible = !mesaMovendo && !gameState.aguardandoReset;
        ghostStopBall.visible = !mesaMovendo && !gameState.aguardandoReset && rawForca > 0.05;
        
        if(ghostBall.visible) { 
            ghostBall.position.set(branca.position.x + dX*distColisao, Y_BOLAS, branca.position.z + dZ*distColisao); 
            const meuTipo = (gameState.turno === 1) ? gameState.p1Tipo : gameState.p2Tipo;
            let corMira = 0xffffff, opMira = 0.15;
            if(alvoMira) {
                if(alvoMira.userData.numero === 1) { corMira = 0xff0000; opMira = 0.6; } 
                else if(gameState.modoDefinido) {
                    if(alvoMira.userData.tipo === meuTipo) { corMira = 0x00ff00; opMira = 0.6; } 
                    else { corMira = 0xff0000; opMira = 0.6; }
                } else { corMira = 0xffffff; opMira = 0.3; }
            }
            ghostBall.material.color.setHex(corMira);
            ghostBall.material.opacity = opMira;
            const distMaxForca = (Math.pow(rawForca, 1.6)*4.2 / (1-FRICCAO))/6;
            const distFinal = Math.min(distColisao, distMaxForca);
            ghostStopBall.position.set(branca.position.x + dX*distFinal, Y_BOLAS + 0.01, branca.position.z + dZ*distFinal);
            ghostStopBall.material.color.setHex(gameState.turno === 1 ? 0x00ff88 : 0x00d9ff);
        }
        
        taco.visible = !mesaMovendo && !gameState.aguardandoReset;
        if(taco.visible) { const db = 13.5 + rawForca*6; taco.position.set(branca.position.x - dX*db, Y_BOLAS+0.2, branca.position.z - dZ*db); taco.lookAt(branca.position.x, Y_BOLAS, branca.position.z); taco.rotateX(-Math.PI/2); }
        
        camera.position.lerp(new THREE.Vector3(alvoCamera.position.x - dX*(1 + altCam*0.9), altCam, alvoCamera.position.z - dZ*(1 + altCam*0.9)), 0.08);
        camera.userData.currentLook.lerp(alvoCamera.position, 0.08); camera.lookAt(camera.userData.currentLook);
        renderer.render(scene, camera);
    }
    loop();
</script>  
</body>  
</html>

Mas arruma essa tem ml deixa igual esse que tá aqui mas adiciona as regras que eu pedi ao menu de bolinho
